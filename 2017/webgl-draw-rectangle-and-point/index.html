<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><title>WebGL 三维教程 - 绘制矩形和点（二） | Sanonz</title><meta name="author" content="Sanonz"><meta name="version" content="1.0.0"><meta name="keywords" content="Sanonz、blog"><meta name="description" content="Canvas 简介在 HTML5 出现之前，如果想要在网页上显示图像，只能使用 HTML 提供的 &amp;lt;img&amp;gt; 标签。用这个标签虽然简单，但是只能显示静态的图片，不能进行实时绘制和渲染，所以后来出现了一些第三方的解决方案，比如 Flash Player 等。Canvas 中文译为“画布”，作为画布我们可以使用 HTMLCanvasElement.getContext(contextType) 获取 Canvas 的上下文，然后使用上下文提供的 API 在画布区域绘制图案，接下来分别介绍"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="baidu-site-verification" content="F0CXvmUgA9"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/style.css"></head><body><div class="app"><header class="header clearfix"><div id="nav" class="nav"><button id="open-panel" class="open-panel"><i class="icon-library"></i></button><nav class="nav-inner"><li class="nav-item"><a class="nav-link" href="/">首页</a></li><li class="nav-item"><a class="nav-link" href="/categories/front-end">前端</a></li><li class="nav-item"><a class="nav-link" href="/categories/back-end">后端</a></li><li class="nav-item nav-item-tag"><a id="nav-tag" class="nav-link" href="#">标签</a><div id="nav-tags" class="nav-tag-wrap"><i class="nav-tag-arrow"></i><div class="widget-wrap"><h3 class="widget-title"><i class="icon-tag vm"></i> <span class="vm">标签</span></h3><div class="widget"><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/3D/">3D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Canvas/">Canvas</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Centos/">Centos</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Http/">Http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Nodejs/">Nodejs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebAssembly/">WebAssembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebGL/">WebGL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nginx/">nginx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ubuntu/">ubuntu</a></li></ul></div></div></div></li><li class="nav-item"><a class="nav-link" href="/archives">归档</a></li><li class="nav-item"><a class="nav-link" href="/atom.xml">订阅</a></li><li class="nav-item"><a class="nav-link" href="/about">关于</a></li></nav></div><aside id="aside" class="aside"><div id="aside-mask" class="aside-mask"></div><div id="aside-inner" class="aside-inner"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"><i class="icon-search-stroke"></i></button><input type="hidden" name="sitesearch" value="https://sanonz.github.io"></form><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Canvas-简介"><span class="toc-number">1.</span> <span class="toc-text">Canvas 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维绘制矩形"><span class="toc-number">2.</span> <span class="toc-text">二维绘制矩形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三维绘制矩形"><span class="toc-number">3.</span> <span class="toc-text">三维绘制矩形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三维绘制点"><span class="toc-number">4.</span> <span class="toc-text">三维绘制点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#三维世界的坐标系统"><span class="toc-number">4.1.</span> <span class="toc-text">三维世界的坐标系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#顶点与片元着色器介绍"><span class="toc-number">4.2.</span> <span class="toc-text">顶点与片元着色器介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建着色器步骤"><span class="toc-number">4.3.</span> <span class="toc-text">创建着色器步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#初始化顶点和片元着色器"><span class="toc-number">4.4.</span> <span class="toc-text">初始化顶点和片元着色器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#绘制三维世界中的点"><span class="toc-number">4.5.</span> <span class="toc-text">绘制三维世界中的点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结束语"><span class="toc-number">5.</span> <span class="toc-text">结束语</span></a></li></ol></div></aside></header><div id="content" class="content"><article class="article" itemscope itemprop="blogPost"><header class="article-header"><h1 itemprop="name">WebGL 三维教程 - 绘制矩形和点（二）</h1><div class="article-meta clearfix"><a class="article-date" href="/2017/webgl-draw-rectangle-and-point/"><i class="icon-calendar"></i> <time datetime="2017-11-03T11:29:20.000Z" itemprop="datePublished">2017-11-03</time></a><div class="article-tag-list"><i class="icon-tag"></i> <a class="article-tag-link" href="/tags/3D/">3D</a>, <a class="article-tag-link" href="/tags/Canvas/">Canvas</a>, <a class="article-tag-link" href="/tags/JavaScript/">JavaScript</a>, <a class="article-tag-link" href="/tags/WebGL/">WebGL</a></div></div></header><section class="article-body markdown-body"><h3 id="Canvas-简介"><a href="#Canvas-简介" class="headerlink" title="Canvas 简介"></a>Canvas 简介</h3><p>在 HTML5 出现之前，如果想要在网页上显示图像，只能使用 HTML 提供的 <code>&lt;img&gt;</code> 标签。用这个标签虽然简单，但是只能显示静态的图片，不能进行实时绘制和渲染，所以后来出现了一些第三方的解决方案，比如 Flash Player 等。</p><p>Canvas 中文译为“画布”，作为画布我们可以使用 <code>HTMLCanvasElement.getContext(contextType)</code> 获取 Canvas 的上下文，然后使用上下文提供的 API 在画布区域绘制图案，接下来分别介绍怎么使用二维和三维的方法绘制矩形和点。</p><a id="more"></a><p>contextType 的取值如下：</p><ol><li><code>&quot;2d&quot;</code> 建立一个 <code>CanvasRenderingContext2D</code> 对象，代表一个二维渲染上下文。</li><li><code>&quot;webgl&quot;</code> 或 <code>&quot;experimental-webgl&quot;</code> 这将创建一个 <code>WebGLRenderingContext</code> 代表三维渲染上下文对象 (OpenGL ES 2.0)。</li></ol><h3 id="二维绘制矩形"><a href="#二维绘制矩形" class="headerlink" title="二维绘制矩形"></a>二维绘制矩形</h3><p>首先要写一个 canvas 元素，然后获取二维渲染的上下文：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"gl"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></div></pre></td></tr></table></figure><p>绘制二维矩形很简单，只需要调用上下文的 <code>ctx.fillRect(x, y, width, height)</code> 方法即可，语法如下：</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>x</td><td>矩形起始点的 x 轴坐标</td></tr><tr><td>y</td><td>矩形起始点的 y 轴坐标</td></tr><tr><td>width</td><td>矩形的宽度</td></tr><tr><td>height</td><td>矩形的高度</td></tr></tbody></table><p>在调用之前首先使用 <code>ctx.fillStyle</code> 设置要填充的颜色，这里我们填充的是蓝色，具体绘制矩形的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'gl'</span>).getContext(<span class="string">'2d'</span>);</div><div class="line">ctx.fillStyle = <span class="string">'rgba(0, 0, 255, 1.0)'</span>;</div><div class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">300</span>);</div></pre></td></tr></table></figure><p>运行效果为一个蓝色的矩形 <a href="https://stackblitz.com/edit/canvas-draw-rectangle" target="_blank" rel="noopener">点击运行</a>：</p><img src="/2017/webgl-draw-rectangle-and-point/draw-rectangle-blue@2x.png" width="320" height="316"><h3 id="三维绘制矩形"><a href="#三维绘制矩形" class="headerlink" title="三维绘制矩形"></a>三维绘制矩形</h3><p>和二维绘制矩形一样，在三维绘制一个矩形也是很简单的，首先要获取 <code>WebGLRenderingContext</code> 的对象，其次是调用 <code>gl.clearColor(red, green, blue, alpha)</code> 设置背景色，语法如下：</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>red</td><td>指定清除缓冲时的红色值。默认值：0</td></tr><tr><td>green</td><td>指定清除缓冲时的绿色值。默认值：0</td></tr><tr><td>blue</td><td>指定清除缓冲时的蓝色值。默认值：0</td></tr><tr><td>alpha</td><td>指定清除缓冲时的不透明度。默认值：0</td></tr></tbody></table><p>下面列出的是一些常用的颜色：</p><table><thead><tr><th>色值</th><th>描述</th></tr></thead><tbody><tr><td>(1.0, 0.0, 0.0, 1.0)</td><td>红色</td></tr><tr><td>(0.0, 1.0, 0.0, 1.0)</td><td>绿色</td></tr><tr><td>(0.0, 0.0, 1.0, 1.0)</td><td>蓝色</td></tr><tr><td>(1.0, 1.0, 0.0, 1.0)</td><td>黄色</td></tr><tr><td>(1.0, 0.0, 1.0, 1.0)</td><td>紫色</td></tr><tr><td>(0.0, 1.0, 1.0, 1.0)</td><td>青色</td></tr><tr><td>(1.0, 1.0, 1.0, 1.0)</td><td>白色</td></tr></tbody></table><p>然后在调用 <code>gl.clear(mask)</code> 用背景色清空 canvas 绘图区域，<code>mask</code> 参数为指定待清空的缓冲区，可以使用位操作符 <code>OR(|)</code> 来指定多个缓冲区，可以取的常量如下：</p><table><thead><tr><th>常量</th><th>表述</th></tr></thead><tbody><tr><td>gl.COLOR_BUFFER_BIT</td><td>指定颜色缓冲区</td></tr><tr><td>gl.DEPTH_BUFFER_BIT</td><td>指定深度缓冲区</td></tr><tr><td>gl.STENCIL_BUFFER_BIT</td><td>指定模版缓冲区</td></tr></tbody></table><p>这里我们设置的背景色为黑色，最后的代码如下，运行后我们想要的矩形就出来了，这个也是最短的 WebGL 程序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'gl'</span>).getContext(<span class="string">'webgl'</span>);</div><div class="line">gl.clearColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</div><div class="line">gl.clear(<span class="keyword">this</span>.gl.COLOR_BUFFER_BIT);</div></pre></td></tr></table></figure><p>运行效果为一个黑色矩形 <a href="https://stackblitz.com/edit/webgl-draw-rectangle" target="_blank" rel="noopener">点击运行</a>：</p><img src="/2017/webgl-draw-rectangle-and-point/draw-rectangle-black@2x.png" width="318" height="318"><h3 id="三维绘制点"><a href="#三维绘制点" class="headerlink" title="三维绘制点"></a>三维绘制点</h3><p>前边我们分别使用三行代码分别绘制了二维与三维的矩形，我们知道，在二维世界坐标是 <code>(x, y)</code>，在三维世界比二维多了一个 <code>z</code> （深度），坐标也就是 <code>(x, y, z)</code>，然后推测根据二维的代码多加一个 <code>z</code> 坐标应该就能画三维中的矩形，修改代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ctx = <span class="built_in">document</span>.getElementById(<span class="string">'gl'</span>).getContext(<span class="string">'webgl'</span>);</div><div class="line">gl.drawColor(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</div><div class="line">gl.drawPoint(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>); <span class="comment">// 点的位置和大小</span></div></pre></td></tr></table></figure><p>然而事情并没有那么简单，当我们运行代码发现出错了，实际的三维绘图要比二维复杂的多，WebGL 依赖于一种新的称为 <em>着色器</em> (shader) 的绘图机制，上一篇 <a href="/2017/webgl-introduction/" title="WebGL 三维教程 - WebGL 介绍（一）">WebGL 三维教程 - WebGL 介绍（一）</a> 我们简单介绍了 WebGL，其中有提及到 GLSL (OpenGL Shading Language)，那么 GLSL 到底是什么呢？GLSL 为着色语言，用来编写 shader 脚本，着色器分为 <em>顶点着色器</em> (Vertex shader) 与 <em>片元着色器</em> (Fragment shader) 两部分，着色器提供了灵活而强大的绘制二维或三维图形的方法，正是因为它的强大，因此也带来了使用上的复杂度，接下来的教程中，我们将一步步去深入研究和理解它。</p><h4 id="三维世界的坐标系统"><a href="#三维世界的坐标系统" class="headerlink" title="三维世界的坐标系统"></a>三维世界的坐标系统</h4><p>WebGL 中的坐标是由 (x, y, z) 组成，下图描述了 WebGL 坐标系。z 轴表示深度，正值 z 表示对象在屏幕/查看器附近，而负值 z 表示该对象不在屏幕上。同样，x 的正值表示对象是屏幕右侧，负值表示对象是左侧。同样，y 的正值和负值表示对象位于屏幕顶部或底部的底部。</p><img src="/2017/webgl-draw-rectangle-and-point/coordinate.png"><h4 id="顶点与片元着色器介绍"><a href="#顶点与片元着色器介绍" class="headerlink" title="顶点与片元着色器介绍"></a>顶点与片元着色器介绍</h4><ul><li>顶点你着色器是用来描述顶点特征（如位置、颜色等）的程序。<em>顶点</em> 是指二维或三维空间中的一个点，将这些顶点连接起来，可以形成线或三角形，WebGL 中最常用的是三角形。</li><li>片元着色器是进行逐片元处理过程的程序，如处理光照，片元史 WebGL 术语，可以理解为像素。</li></ul><h4 id="创建着色器步骤"><a href="#创建着色器步骤" class="headerlink" title="创建着色器步骤"></a>创建着色器步骤</h4><p>(一)、使用 <code>gl.createProgram()</code> 方法用于创建和初始化一个 <code>WebGLProgram</code> 对象。<br>(二)、使用 <code>gl.createShader(type)</code> 创建一个 <code>WebGLShader</code> 着色器对象。</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>type</td><td>gl.VERTEX_SHADER 为顶点着色器，gl.FRAGMENT_SHADER 为片元着色器</td></tr></tbody></table><p>(三)、使用 <code>gl.shaderSource(shader, source)</code> 挂接 <code>source</code> (GLSL) 源代码到 <code>shader</code> 上。</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>shader</td><td>包含顶点着色器和片元着色器的 <code>WebGLShader</code> 对象</td></tr><tr><td>source</td><td>一坨字符串，也就是着色器 (GLSL) 语言代码</td></tr></tbody></table><p>(四)、使用 <code>gl.compileShader(shader)</code> 编译一个 GLSL 着色器，使其成为为二进制数据，然后就可以被 <code>WebGLProgram</code> 对象所使用。</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>shader</td><td>一个片元或顶点着色器</td></tr></tbody></table><p>(五)、使用 <code>gl.attachShader(program, shader)</code> 方法把着色器 <code>shader</code> 添加到 <code>program</code>。</p><table><thead><tr><th>参数</th><th>表述</th></tr></thead><tbody><tr><td>program</td><td>包含顶点着色器和片元着色器的 <code>WebGLProgram</code> 对象</td></tr><tr><td>shader</td><td>一个类型为片段或者顶点的 <code>WebGLShader</code> 对象</td></tr></tbody></table><p>(六)、使用 <code>gl.linkProgram(program)</code> 和 <code>gl.useProgram(program)</code> 分别链接和使用 <code>WebGLProgram</code> 对象。</p><p>综上六个步骤就可以创建一个顶点着色器或片元着色器，为了方便这里把创建着色器封装成了一个 <code>createShader(type, source)</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  createShader(type, source) &#123;</div><div class="line">    <span class="comment">// 创建一个`WebGLShader`着色器对象，`type`为`gl.VERTEX_SHADER`(顶点着色器)或`gl.FRAGMENT_SHADER`片元着色器</span></div><div class="line">    <span class="keyword">const</span> shader = <span class="keyword">this</span>.gl.createShader(type);</div><div class="line"></div><div class="line">    <span class="comment">// 挂接`source`(GLSL)源代码到`shader`上</span></div><div class="line">    <span class="keyword">this</span>.gl.shaderSource(shader, source);</div><div class="line"></div><div class="line">    <span class="comment">// 编译`shader`(GLSL)为二进制文件，以便被`WebGLProgram`使用</span></div><div class="line">    <span class="keyword">this</span>.gl.compileShader(shader);</div><div class="line"></div><div class="line">    <span class="comment">// 添加一个片元着色器或者顶点着色器</span></div><div class="line">    <span class="keyword">this</span>.gl.attachShader(<span class="keyword">this</span>.shaderProgram, shader);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> shader;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="初始化顶点和片元着色器"><a href="#初始化顶点和片元着色器" class="headerlink" title="初始化顶点和片元着色器"></a>初始化顶点和片元着色器</h4><p>接下来在添加一个 <code>constructor()</code> 和 <code>initShader()</code> 方法，用来获取 <code>WebGLRenderingContext</code> 对象和初始化顶点着色器和片元着色器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.gl = self.gl = <span class="built_in">document</span>.getElementById(<span class="string">'gl'</span>).getContext(<span class="string">'webgl'</span>);</div><div class="line">    <span class="keyword">this</span>.gl.viewport(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">this</span>.gl.drawingBufferWidth, <span class="keyword">this</span>.gl.drawingBufferHeight);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  initShader() &#123;</div><div class="line">    <span class="comment">// 创建一个`WebGLProgram`</span></div><div class="line">    <span class="keyword">this</span>.shaderProgram = <span class="keyword">this</span>.gl.createProgram();</div><div class="line"></div><div class="line">    <span class="comment">// 创建顶点着色器</span></div><div class="line">    <span class="keyword">this</span>.createShader(<span class="keyword">this</span>.gl.VERTEX_SHADER, <span class="string">`</span></div><div class="line"><span class="string">      attribute vec4 a_Position;</span></div><div class="line"><span class="string"></span></div><div class="line"><span class="string">      void main() &#123;</span></div><div class="line"><span class="string">        gl_Position = a_Position;</span></div><div class="line"><span class="string">        gl_PointSize = 10.0;</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    `</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 创建片元着色器</span></div><div class="line">    <span class="keyword">this</span>.createShader(<span class="keyword">this</span>.gl.FRAGMENT_SHADER, <span class="string">`</span></div><div class="line"><span class="string">      void main() &#123;</span></div><div class="line"><span class="string">        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);</span></div><div class="line"><span class="string">      &#125;</span></div><div class="line"><span class="string">    `</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 分别链接和使用</span></div><div class="line">    <span class="keyword">this</span>.gl.linkProgram(<span class="keyword">this</span>.shaderProgram);</div><div class="line">    <span class="keyword">this</span>.gl.useProgram(<span class="keyword">this</span>.shaderProgram);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上边程序中第 16-21 行编写了顶点着色器，26-28 行编写了片元着色器，从这两块的程序中可以看出，GLSL 语言是跟 C 语言非常类似的，都必须包含一个 <code>main()</code> 函数，<code>main()</code> 前边的关键字 <code>void</code> 是表示这个函数不会有返回值，还有不能为 <code>main()</code> 函数指定参数。</p><p>在顶点着色器和中使用了：<code>gl_Position</code>、<code>gl_Position</code> 和片元着色器中的： <code>gl_FragColor</code>，这些分别为内置的变量，我们把相应的值赋值给相应的内置变量就可以得到相应的渲染结果，它们的功能如下：</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>gl_Position</td><td>表示顶点位置</td></tr><tr><td>gl_Position</td><td>表示点的尺寸</td></tr><tr><td>gl_FragColor</td><td>指定片元颜色（RGBA）</td></tr></tbody></table><p>并且 GLSL 语言为强类型语言，如果把第 20 行的 <code>gl_PointSize = 10.0</code> 改为 <code>gl_PointSize = 10</code> 就会导致程序报错，上边使用到的类型介绍如下：</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>float</td><td>表示浮点数</td></tr><tr><td>vec4</td><td>表示由四个浮点数组成的矢量，另外三种：vec1、vec2、vec3</td></tr></tbody></table><p>其中 <code>vec4</code> 在这里有两种身份，它既能声明变量类型： <code>attribute vec4 a_Position</code>，又能作为 <em>构造函数</em> (Constructor Functions) 使用：<code>gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0)</code>，构造函数的名称和创建的变量的名称是一致的。最前边的关键 <code>attribute</code> 被称为 <em>储存限定符</em> (Storage Qualifier)，<code>attribute</code> 必须声明为全局变量，数据将从着色器外部传给该变量。</p><p>着色器初始化完成后就可以开始画点了，步骤如下：</p><p>(一)、使用 <code>gl.getAttribLocation(program, name)</code> 方法获取 <code>attribute</code> 变量的储存位置。</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>program</td><td>包含顶点着色器和片元着色器的 <code>WebGLProgram</code> 对象</td></tr><tr><td>name</td><td>着色器 <code>attribute</code> 变量的名称</td></tr></tbody></table><p>(二)、使用 <code>gl.vertexAttrib3f(index, v0, v1, v2)</code> 方法向 <code>attribute</code> 变量赋值。</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>index</td><td><code>attribute</code> 的储存位置</td></tr><tr><td>v0</td><td>指定填充 <code>attribute</code> 变量第一个分量的值</td></tr><tr><td>v1</td><td>指定填充 <code>attribute</code> 变量第二个分量的值</td></tr><tr><td>v2</td><td>指定填充 <code>attribute</code> 变量第三个分量的值</td></tr></tbody></table><p>(三)、使用 <code>gl.drawArrays(mode, first, count)</code> 方法进行绘制。</p><table><thead><tr><th>类型</th><th>表述</th></tr></thead><tbody><tr><td>mode</td><td>绘制的方式，可以选择的常量：gl.POINTS、gl.LINES、gl.LINE_STRIP、gl.LINE_LOOP、gl.TRIANGLES、gl.TRIANGLE_STRIP、gl.TRIANGLE_FAN</td></tr><tr><td>first</td><td>指定从哪个顶点开始绘制</td></tr><tr><td>count</td><td>指定绘制需要多少个顶点</td></tr></tbody></table><p><code>mode</code> 可以绘制的基本图形解析：</p><table><thead><tr><th>mode</th><th>图形</th><th>表述</th></tr></thead><tbody><tr><td>gl.POINTS</td><td>点</td><td>一系列点，绘制在 v0、v1、v2 … 处</td></tr><tr><td>gl.LINES</td><td>线段</td><td>一系列单独的线段，绘制在 (v0, v1)、(v2, v3)、(v4, v5) … 处，如果点的个数是奇数，最后一个点将被忽略</td></tr><tr><td>gl.LINE_STRIP</td><td>线条</td><td>一系列连接的线段,被绘制在(v0,v1)、(v1,v2)、(v2,v3) … 处，第 1 个点是第1条线段的起点，第 2 个点是第 1 条线段的终点和第 2 条线段的起点 … 第 i(i&gt;1) 个点是第 i-1 条线段的终点和第 i 条线段的起点，以此类推。最后一个点是最后一条线段的终点</td></tr><tr><td>gl.LINE_LOOP</td><td>回路</td><td>一系列连接的线段。与gl.LINE_STRIP 绘制的线条相比，增加了一条从最后一个点到第1个点的线段。因此，线段被绘制在 (v0, v1)、(v1, v2) … (vn, v0) 处，其中 vn 是最后一个点</td></tr><tr><td>gl.TRIANGLES</td><td>三角形</td><td>一系列单独的三角形，绘制在 (v0, v1, v2)、(v3, v4, v5) … 处，如果点的个数不是 3 的整数倍，最后剩下的一或两个点将被忽略</td></tr><tr><td>gl.TRIANGLE_STRIP</td><td>三角带</td><td>一系列条带状的三角形，前三个点构成了第 1 个三角形，从第 2 个点开始的三个点构成了第 2 个三角形(该三角形与前一个三角形共享一条边)，以此类推。这些三角形被绘制在 (v0, v1, v2)、(v2, v1, v3)(v2, v3, v4) … 处</td></tr><tr><td>gl.TRIANGLE_FAN</td><td>三角扇</td><td>一系列三角形组成的类似于扇形的图形。前三个点构成了第 1 个三角形，接下来的一个点和前一个三角形的最后一条边组成接下来的一个三角形。这些三角形被绘制在 (v0, v1, v2)、(v0, v2, v3)、(v0, v3, v4) … 处</td></tr></tbody></table><h4 id="绘制三维世界中的点"><a href="#绘制三维世界中的点" class="headerlink" title="绘制三维世界中的点"></a>绘制三维世界中的点</h4><p>添加一个 <code>drawPoint()</code> 方法进行画点，在运行前我们在 <code>constructor()</code> 方法中分别调用 <code>this.initShader()</code> 和 <code>this.drawPoint()</code> 方法，最终代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.initShader();</div><div class="line">    <span class="keyword">this</span>.drawPoint();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  drawPoint() &#123;</div><div class="line">    <span class="keyword">const</span> a_Position = <span class="keyword">this</span>.gl.getAttribLocation(<span class="keyword">this</span>.shaderProgram, <span class="string">'a_Position'</span>);</div><div class="line">    <span class="keyword">this</span>.gl.vertexAttrib4f(a_Position, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</div><div class="line">    <span class="keyword">this</span>.gl.drawArrays(<span class="keyword">this</span>.gl.POINTS, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>预览效果 <a href="https://stackblitz.com/edit/webgl-draw-point" target="_blank" rel="noopener">点击运行</a>：</p><img src="/2017/webgl-draw-rectangle-and-point/draw-point@2x.png" width="316" height="322"><h3 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h3><p>本文中出现了一些 WebGL 的一些概念，对于初学者来说，你不需要记住本文中的所有东西，在后续的教程中将一步步深入研究这些概念，再加上经常练习才能真正理解，所以，现在还不用太严肃，现在只需要享受阅读，等以后再回头看也不迟。</p></section></article><div class="comments"><div id="disqus_thread"><p class="comment-tips">国内查看评论需要代理~</p></div><script>window.disqus_config=function(){this.language="zh",this.page.url="https://sanonz.github.io/2017/webgl-draw-rectangle-and-point/",this.page.title="WebGL 三维教程 - 绘制矩形和点（二）",this.page.identifier="2017/webgl-draw-rectangle-and-point/"},function(){var t=document,e=t.createElement("script");e.src="https://sanonz.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div><footer class="footer">Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme by <a href="https://github.com/sanonz/hexo-theme-concise" target="_blank">Concise</a></footer><script type="text/javascript" src="//s13.cnzz.com/z_stat.php?id=1271274815&amp;web_id=1271274815"></script></div><script type="text/javascript" src="https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js"></script><script type="text/javascript" src="/js/scrollspy.min.js"></script><script type="text/javascript">$(function(){var a={nav:$("#nav"),aside:$("#aside"),navTags:$("#nav-tags")};$("#open-panel, #aside-mask").on("click",function(){a.aside.toggleClass("panel-show")}),$("#nav-tag").on("click",function(n){n.preventDefault(),console.log(a.navTags.attr("class")),a.navTags.toggleClass("tag-show"),console.log(a.navTags.attr("class"))}),$(document.body).scrollspy({target:"#aside-inner"})})</script></body></html>